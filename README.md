# Free_Coupon

### 공짜쿠폰 랜덤추첨 서비스

자사의 상품을 홍보하고 싶을때 웹 내에서 쿠폰을 생성하고 등록해 놓으면 소비자들이 주어진 티켓으로 응모를 하고 추첨을 통해 쿠폰을 얻을 수 있는 서비스입니다.   
사업자는 쿠폰을 통해 자사의 제품을 대중에게 노출시킴으로써 제품 홍보효과를 얻을 수 있고 사람들은 쿠폰 당첨시 비용없이 제품을 소비할 수 있습니다.

<br>

## *Tech Stack*
***
+ #### SpringBoot
+ #### Spring Security
+ #### Mysql 
+ #### Redis

<br>

## *Service Flow*
***
![service-flow](https://github.com/devhongsa/Free_Coupon/assets/100022877/1a73380c-f894-46b9-9d2e-1b379819aae2)




<br>

## *API 기능*
***

### 공동 API

- 회원가입/로그인 : 파트너/일반유저의 가입폼이 다름
- (후순위) 회원정보 수정하기 : 정보 수정
- (후순위) 계정 비활성화
- 쿠폰 목록 보기 : 응모가능 목록에 올라온 쿠폰들을 보여줌
  - 카테고리별 검색기능 ( 커피/음료, 치킨, 피자, 패스트푸드, 기타외식 .. 등)
  - 검색어로 검색 기능 ( 특정 쿠폰 검색 )


### 파트너 회원 전용 API 

- 쿠폰 템플릿 생성하기 : 쿠폰 기본 템플릿을 생성, 쿠폰 등록의 편의성과 유연성 제공 
- 템플릿 수정하기 : 템플릿 정보를 수정할 수 있다. 템플릿 정보 중에 수정을 못하는 정보 존재 (쿠폰카테고리, 쿠폰의 가치, 쿠폰 이름)
- 템플릿 삭제하기 : 템플릿 삭제
- 템플릿 목록보기 : 쿠폰 템플릿 목록 보기 
- 쿠폰 등록하기 : 템플릿 쿠폰을 쿠폰 응모가능 목록에 올리기, 몇장의 쿠폰을 올릴건지도 선택, (후순위 기능: 같이 올라갈 광고선택)
- 발급 쿠폰 목록보기 : 파트너가 발급한 QR쿠폰 목록을 보여준다.
- 쿠폰 정보 확인하기 : 소비자가 가져온 QR 쿠폰 정보를 확인한다(자신이 발급한 쿠폰이 맞는지, 이미 사용된 쿠폰인지, 유효기간이 남았는지 확인)
- 쿠폰 사용 처리하기 : QR 쿠폰을 사용처리한다.
- (후순위 기능) 광고 등록하기 : 쿠폰에 붙을 추가광고 이미지나 url링크 등록 


### 일반 회원 전용 API
- 응모하기 : 쿠폰에 응모하기
- 당첨쿠폰 목록 보기 : 당첨된 쿠폰 목록을 볼 수 있다
- (후순위 기능) 응모취소하기 : 응모취소
- (후순위 기능) 광고보기 : 해당 쿠폰의 광고를 보면 티켓소모없이 응모가능 


### Admin 전용 API
- (후순위 기능) : 당첨된 유저에게 당첨소식을 알리는 기능 (휴대폰번호 혹은 이메일로 알림)

<br>


## *ERD*
***
![free-coupon-erd](https://github.com/devhongsa/Free_Coupon/assets/100022877/88d4f355-b292-466b-a978-e30d2c3ce6ec)



- User : 일반 유저 테이블 
- Partner : 파트너 유저 테이블 
- Coupon_Template : 파트너의 쿠폰템플릿 테이블. 파트너가 쿠폰 템플릿을 만들어놓으면 템플릿을 사용해서 쿠폰 재등록시 편의성을 제공 
- Coupon_Feed : 파트너가 쿠폰을 등록하면, 응모가능 쿠폰 목록에 등록되게 됨.
- Coupon_Qr : 쿠폰 추첨이 완료되면 QR쿠폰이 생성되고 당첨된 유저의 쿠폰당첨목록에 쿠폰정보가 보여지게 됨.
- Feed_Participant : 회원들이 어떤 피드에 응모를 했는지에 대한 데이터 테이블

<br>


## *문제 해결 과정*
***

1. 값 컬렉션 성능 문제 (converter 사용)   
   회원 권환 정보를 저장하기 위해 처음에는 @ElementCollection을 사용해서 권한 정보가 별도의 테이블에 관리가 되도록 기능을 구현했다.
   하지만 ElementCollection을 사용하다보니 단점들이 많이 존재했었다.
   첫 번째로 N+1 문제가 발생한다. 회원이 서버에 요청할때마다 Filter에서 회원 권한 정보를 조회하게 되는데 이때 불필요하게 쿼리가 늘어난다.
   두 번째로 권한 추가 및 삭제 시 성능 문제가 있다. ElementCollection은 List형태로 통채로 저장되는 구조라 모든 값을 삭제했다가 다시 삽입하는 구조이다.
   물론 권한의 종류가 많지 않아서 크게 성능에 영향을 미치진 않겠지만, 그래도 단점인 것은 명확하다
   세 번째로, 권한 테이블에는 식별자가 존재하지 않기 때문에 각 요소를 조회하거나 수정이 불가능하다.

   이러한 이유들로 결국 @ElementCollection이 아닌 Converter를 사용하기로 했다.
   Converter는 "ROLE_CUSTOMER,ROLE_ADMIN" 와 같이 DB에 String 형태로 저장된 값을 리스트로 바꿔주고 리스트 내용을 String 형태로 바꿔줘서 DB에 저장하는 역할을 한다.
   Converter 클래스는 구글에 검색해보니 좋은 코드들이 많아 참고해서 작성하였다.
   @ElementCollection은 구현이 간편하다는 점이 장점이긴 하지만, 성능을 생각하면 역시 Converter를 사용하는 것이 좋을 것 같다.
   

2. N+1 문제, Paging 문제   
   Partner 엔티티에 List<CouponTemplate> templates 필드가 있고 templates를 @OneToMany로 연관관계를 설정해주었다.
   이후 partner를 조회하는 쿼리를 실행할때마다 partner가 생성한 CouponTemplate 개수만큼 쿼리가 추가로 발생하는 것을 발견했고, 문제를 찾아보니
   아주 유명한 N+1문제가 바로 이것이었다. 해결방법으로 fetch Lazy설정, fetch join으로 쿼리를 실행해서 우선 N+1문제를 해결할 수 있었다.
   
   그런데 N+1문제에 대해서 공부하다보니 fetch join은 pagination 처리시 굉장히 비효율적이었다. 원래 paging처리를 하면 Limit, Offset를 사용하여
   쿼리를 날려야하는데, fetch join을 적용하면 DB에서 일단 모든 데이터를 인메모리에 저장해놓고 그 중에 내가 설정한 데이터 개수만큼 잘라서 준다는 것이었다.
   물론 현재 Partner는 paging으로 조회 쿼리를 날리는 로직은 없지만, Feed 엔티티에서는 paging처리를 할 것이기 때문에 이문제는 짚고 넘어가야 했다.
   특히 Feed 엔티티에는 굉장히 많은 데이터가 들어갈 것이기 때문에 기존의 fetch join 방식으로 페이징 처리를 하면 OOM이 발생할 확률이 컸다.

   해결방법으로는 @BatchSize로 가져올 데이터를 제한하는 것이었는데, 이렇게 하면 모든 데이터를 가져오지 않고 내가 설정한 개수만큼 Where in()으로 쿼리를 날려
   paging처리를 하는 것이었다. 이러면 OOM이 발생할 확률도 거의 없고, paging처리도 잘 할 수 있을것 같다.
   
   
4. 물리적 FK   
   현업에서 물리적 FK를 거의 사용하지 않는다고 들었는데, 그 이유를 체감하지 못하다가 이번에 TestCode를 작성하면서 이유를 알게되었다.
   TestCode에서 테스트 엔티티를 생성할때 그 엔티티와 연관된 모든 엔티티들도 같이 생성해 주어야 했다.. 그래서 테스트가 정말 하기 싫어졌고
   통일된 데이터를 한번에 만들어놓고 공통으로 사용할까 생각했지만, 테스트마다 공통된 데이터를 변환해야 될 때가 있기 때문에 다른 테스트에 영향을 줄 수 있었다.
   검색해보니 역시나 나와 똑같은 생각을 한 사람들이 이미 있었고, 연관관계가 있는 필드에 foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)를
   선언해줘서 FK를 다 없애게 되었다. Fk 부재로 발생할 수 있는 데이터 정합성의 문제에 대해서는 로직 내에서 해결하는 게 나을 것 같다. 
  
5. 쿠폰 사용 처리 문제 (uuid 사용)
   
   
